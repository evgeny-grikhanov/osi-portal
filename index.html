<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–î–æ–∫—É–º–µ–Ω—Ç—ã Nest One</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/@pdf-lib/fontkit@1.1.1/dist/fontkit.umd.min.js"></script>

    <style>
        body { margin: 0; background: #1a1a1a; color: #fff; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; min-height: 100vh; }
        
        #header { 
            width: 100%; background: #000; padding: 15px 0; 
            border-bottom: 2px solid #d4af37; 
            position: sticky; top: 0; z-index: 100; 
            display: flex; justify-content: center; align-items: center; gap: 15px; 
            flex-wrap: wrap;
        }

        #title { font-weight: bold; letter-spacing: 1px; margin-right: 20px; }

        .btn {
            background-color: #333; color: #fff; border: 1px solid #555;
            padding: 8px 15px; border-radius: 4px; cursor: pointer;
            font-size: 14px; transition: 0.3s; display: flex; align-items: center; gap: 5px;
            text-decoration: none;
        }
        .btn:hover { background-color: #d4af37; color: #000; border-color: #d4af37; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; background-color: #222; color: #777; border-color: #333; }

        #viewer { display: flex; flex-direction: column; align-items: center; padding: 20px 10px; width: 100%; max-width: 1000px; }
        canvas { max-width: 100%; height: auto; margin-bottom: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); background: #fff; border-radius: 4px; }
        
        #loader { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 80vh; }
        .spinner { border: 4px solid rgba(255,255,255,0.1); border-top: 4px solid #d4af37; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 15px; }
        #status { color: #aaa; font-size: 14px; }
    </style>
</head>
<body>

<div id="header">
    <span id="title">–ó–ê–©–ò–©–ï–ù–ù–´–ô –ü–†–û–°–ú–û–¢–†</span>
    <button id="btnDownload" class="btn" onclick="handleAction('download')" disabled>üì• –°–∫–∞—á–∞—Ç—å</button>
    <button id="btnPrint" class="btn" onclick="handleAction('print')" disabled>üñ®Ô∏è –ü–µ—á–∞—Ç—å</button>
</div>

<div id="loader">
    <div class="spinner"></div>
    <div id="status">–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
</div>

<div id="viewer"></div>

<script>
    const API = 'https://script.google.com/macros/s/AKfycbwh9dwQE_8lM3ZYbEEVyo4DwUC3RFdcXTi_tdBhmIjt237exEIiQFzW0uS11OQfzyDW/exec';
    
    const params = new URLSearchParams(window.location.search);
    const fid = params.get('fid');
    const uid = params.get('id');

    // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
    let rawPdfBytes = null; // –ó–¥–µ—Å—å –±—É–¥–µ—Ç –ª–µ–∂–∞—Ç—å Uint8Array (–≥–æ—Ç–æ–≤—ã–π –¥–ª—è pdf-lib)
    let watermarkData = [];

    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    // === –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –î–õ–Ø –ö–û–ù–í–ï–†–¢–ê–¶–ò–ò ===
    function base64ToUint8Array(base64) {
        // –û—á–∏—â–∞–µ–º –æ—Ç –≤–æ–∑–º–æ–∂–Ω—ã—Ö –ø—Ä–æ–±–µ–ª–æ–≤ –∏ –ø–µ—Ä–µ–Ω–æ—Å–æ–≤ —Å—Ç—Ä–æ–∫
        const raw = atob(base64.replace(/\s/g, ''));
        const rawLength = raw.length;
        const array = new Uint8Array(rawLength);
        for (let i = 0; i < rawLength; i++) {
            array[i] = raw.charCodeAt(i);
        }
        return array;
    }

    // 1. –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
    async function init() {
        if (!fid || !uid) { showError('–û—à–∏–±–∫–∞ —Å—Å—ã–ª–∫–∏'); return; }

        try {
            const [pdfRes, userRes] = await Promise.all([
                fetch(`${API}?action=getPdf&fid=${fid}`),
                fetch(`${API}?action=getUserInfo&id=${uid}`)
            ]);

            const pdfJson = await pdfRes.json();
            const userJson = await userRes.json();

            if (!pdfJson.success) throw new Error("–§–∞–π–ª –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω");

            // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º Base64 –≤ Uint8Array —Å—Ä–∞–∑—É
            rawPdfBytes = base64ToUint8Array(pdfJson.base64);

            const userName = userJson.success ? userJson.name : '–°–æ–±—Å—Ç–≤–µ–Ω–Ω–∏–∫';
            const userRoom = userJson.success ? userJson.premises : '---';
            const dateStr = new Date().toLocaleDateString('ru-RU');

            watermarkData = [
                `${userName} (ID: ${uid})`,
                `–ü–æ–º–µ—â–µ–Ω–∏–µ: ${userRoom}`,
                `–î–∞—Ç–∞: ${dateStr}`
            ];

            // –†–∏—Å—É–µ–º –ø—Ä–µ–≤—å—é
            renderPreview(rawPdfBytes, watermarkData);

            // –í–∫–ª—é—á–∞–µ–º –∫–Ω–æ–ø–∫–∏
            document.getElementById('btnDownload').disabled = false;
            document.getElementById('btnPrint').disabled = false;

        } catch (e) { showError('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞: ' + e.message); }
    }

    // 2. –û–¢–†–ò–°–û–í–ö–ê (Canvas)
    async function renderPreview(pdfData, lines) {
        document.getElementById('status').innerText = '–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞...';
        // PDF.js –æ—Ç–ª–∏—á–Ω–æ –ø–æ–Ω–∏–º–∞–µ—Ç Uint8Array
        const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
        document.getElementById('loader').style.display = 'none';

        for (let n = 1; n <= pdf.numPages; n++) {
            const page = await pdf.getPage(n);
            const viewport = page.getViewport({ scale: 1.5 });
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.height = viewport.height; canvas.width = viewport.width;

            await page.render({ canvasContext: ctx, viewport: viewport }).promise;
            drawCanvasWatermark(canvas, lines);
            document.getElementById('viewer').appendChild(canvas);
        }
    }

    function drawCanvasWatermark(canvas, lines) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width; const h = canvas.height;
        ctx.save();
        
        const fontSize = Math.max(16, Math.round(w / 50));
        ctx.font = `bold ${fontSize}px Arial`;
        ctx.fillStyle = "rgba(255, 0, 0, 0.25)";
        ctx.textAlign = "center"; ctx.textBaseline = "middle";

        let maxWidth = 0;
        lines.forEach(l => { const m = ctx.measureText(l); if(m.width>maxWidth) maxWidth=m.width; });
        
        const lineHeight = fontSize * 1.1;
        const blockHeight = lines.length * lineHeight;
        const stepX = maxWidth + 60; const stepY = blockHeight + 50;

        ctx.translate(w/2, h/2); ctx.rotate(-45 * Math.PI / 180);
        const diag = Math.sqrt(w*w + h*h) + 500;

        for (let y = -diag; y < diag; y += stepY) {
            const rowShift = (Math.floor(y/stepY)%2 === 0) ? 0 : stepX/2;
            for (let x = -diag; x < diag; x += stepX) {
                lines.forEach((l, i) => {
                    const ly = y + (i - (lines.length-1)/2) * lineHeight;
                    ctx.fillText(l, x + rowShift, ly);
                });
            }
        }
        ctx.restore();
    }

    // 3. –ì–ï–ù–ï–†–ê–¶–ò–Ø (PDF-Lib)
    async function handleAction(type) {
        const btn = document.getElementById(type === 'download' ? 'btnDownload' : 'btnPrint');
        const originalText = btn.innerText;
        btn.disabled = true;
        btn.innerText = "‚è≥ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è...";

        try {
            const { PDFDocument, rgb, degrees } = PDFLib;
            
            // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü–µ—Ä–µ–¥–∞–µ–º Uint8Array, –∞ –Ω–µ Base64 —Å—Ç—Ä–æ–∫—É.
            // –¢–µ–ø–µ—Ä—å pdf-lib —Ç–æ—á–Ω–æ –Ω–∞–π–¥–µ—Ç header.
            const pdfDoc = await PDFDocument.load(rawPdfBytes);
            
            pdfDoc.registerFontkit(fontkit);
            const fontUrl = 'https://pdf-lib.js.org/assets/ubuntu/Ubuntu-R.ttf';
            const fontBytes = await fetch(fontUrl).then(res => res.arrayBuffer());
            const customFont = await pdfDoc.embedFont(fontBytes);

            const pages = pdfDoc.getPages();
            const fontSize = 14;
            const lineHeight = 16;
            const opacity = 0.25;
            const color = rgb(1, 0, 0);

            let maxW = 0;
            watermarkData.forEach(l => {
                const w = customFont.widthOfTextAtSize(l, fontSize);
                if(w > maxW) maxW = w;
            });
            
            const stepX = maxW + 80;
            const stepY = (watermarkData.length * lineHeight) + 60;

            pages.forEach(page => {
                const { width, height } = page.getSize();
                const diag = Math.sqrt(width*width + height*height) + 500;

                for (let y = -diag; y < diag; y += stepY) {
                    const rowShift = (Math.floor(y/stepY)%2 === 0) ? 0 : stepX/2;
                    for (let x = -diag; x < diag; x += stepX) {
                        watermarkData.forEach((line, i) => {
                            const offset = (i - (watermarkData.length-1)/2) * lineHeight;
                            page.drawText(line, {
                                x: (width/2) + x + rowShift,
                                y: (height/2) + y - offset,
                                size: fontSize,
                                font: customFont,
                                color: color,
                                opacity: opacity,
                                rotate: degrees(-45),
                            });
                        });
                    }
                }
            });

            const pdfBytes = await pdfDoc.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);

            if (type === 'download') {
                const link = document.createElement('a');
                link.href = url;
                link.download = `NestOne_Doc_${uid}.pdf`;
                link.click();
            } else {
                const iframe = document.createElement('iframe');
                iframe.style.display = 'none';
                iframe.src = url;
                document.body.appendChild(iframe);
                iframe.onload = function() {
                    setTimeout(function() {
                        iframe.contentWindow.print();
                    }, 500);
                };
            }

        } catch (e) {
            alert("–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: " + e.message);
            console.error(e);
        } finally {
            btn.disabled = false;
            btn.innerText = originalText;
        }
    }

    function showError(msg) {
        document.getElementById('status').innerText = msg;
        document.getElementById('status').style.color = '#ff5555';
        document.querySelector('.spinner').style.display = 'none';
    }

    init();
</script>
</body>
</html>
